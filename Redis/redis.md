# NoSql入门和概述  
## 入门概述  
1. 互联网时态背景下大机遇，为什么用nosql  
(1)点击MySQL的美好年代在90年代，一个网站的访问量一般都不大，用单个数据库完全可以轻松应付。
在那个时候，更多的都是静态网页，动态交互类型的网站不多。  
![0](/Redis/redisfile/0.png)  
上述架构下，我们来看看数据存储的瓶颈是什么？  
+ 数据量的总大小 一个机器放不下时  
+ 数据的索引（B+ Tree）一个机器的内存放不下时  
+ 访问量(读写混合)一个实例不能承受  
(2)2 Memcached(缓存)+MySQL+垂直拆分。后来，随着访问量的上升，几乎大部分使用MySQL架构的网站在数据库上都开始出现了性能问题，web程序不再仅仅专注在功能上，同时也在追求性能。程序员们开始大量的使用缓存技术来缓解数据库的压力，优化数据库的结构和索引。开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带了了比较高的IO压力。在这个时候，Memcached就自然的成为一个非常时尚的技术产品。  
![1](/Redis/redisfile/1.png)   
 Memcached作为一个独立的分布式的缓存服务器，为多个web服务器提供了一个共享的高性能缓存服务，在Memcached服务器上，又发展了根据hash算法来进行多台Memcached缓存服务的扩展，然后又出现了一致性hash来解决增加或减少缓存服务器导致重新hash带来的大量缓存失效的弊端。  
 (3)Mysql主从读写分离。由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。Mysql的master-slave模式成为这个时候的网站标配了。  
 ![3](/Redis/redisfile/3.png)   
(4)分表分库+水平拆分+mysql集群。 在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。  
 同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题。这个时候，分表分库成了一个热门技术，是面试的热门问题也是业界讨论的热门技术问题。也就在这个时候，MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的要求，只是在高可靠性上提供了非常大的保证。  
  ![4](/Redis/redisfile/4.png)   
(5)MySQL的扩展性瓶颈。MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题。  
(6)今天是什么样子？？  
  ![5](/Redis/redisfile/5.png)   
(7)为什么用NoSQL。  
今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据  
![6](/Redis/redisfile/6.png)   
2. NoSQL是什么  
NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，
泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。  
（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。  
3. 能干什么  
+ 易扩展  
NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。
数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。
+ 大数据量高性能
+ 多样灵活的数据模型  
NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。
这得益于它的无关系性，数据库的结构简单。
一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，
在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，
是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了

+ 传统RDBMS VS NOSQL  
RDBMS vs NoSQL
RDBMS
- 高度组织化结构化数据
- 结构化查询语言（SQL）
- 数据和关系都存储在单独的表中。
- 数据操纵语言，数据定义语言
- 严格的一致性
- 基础事务  

NoSQL
- 代表着不仅仅是SQL
- 没有声明性查询语言
- 没有预定义的模式
-键 - 值对存储，列存储，文档存储，图形数据库
- 最终一致性，而非ACID属性
- 非结构化和不可预知的数据
- CAP定理
- 高性能，高可用性和可伸缩性  
4. 去哪里下载
Redis、Memcache、Mongdb  
5. 怎么玩  
KV、Cache、Persistence  
## 3V+3高  
1. 大数据时代下的3V  
+ 海量Volume
+ 多样Variety
+ 实时Velocity  
2. 互联网需求的3高  
+ 高并发  
+ 高可扩
+ 高性能
## NoSQL数据模型介绍  
1. 对比关系型数据库和非关系型数据库  
(1)关系型数据库  
![7](/Redis/redisfile/7.png)   
(2)Nosql如何设计  
+ 什么是BSON()  
BSON（）是一种类json的一种二进制形式的存储格式，简称Binary JSON，
它和JSON一样，支持内嵌的文档对象和数组对象  
```json
{
 "customer":{
   "id":1136,
   "name":"Z3",
   "billingAddress":[{"city":"beijing"}],
   "orders":[
    {
      "id":17,
      "customerId":1136,
      "orderItems":[{"productId":27,"price":77.5,"productName":"thinking in java"}],
      "shippingAddress":[{"city":"beijing"}]
      "orderPayment":[{"ccinfo":"111-222-333","txnid":"asdfadcd334","billingAddress":{"city":"beijing"}}],
      }
    ]
  }
}

```  
+ 总结  
```
为什么上述的情况可以用聚合模型来处理  
高并发的操作是不太建议有关联查询的，互联网公司用冗余数据来避免关联查询,分布式事务是支持不了太多的并发的。  
如果按照我们新设计的BSon，是不是查询起来很可爱
```  
2. 聚合模型  
+ KV键值
+ Bson
+ 列族  
顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。
![8](/Redis/redisfile/8.png)   
+ 图形  
![9](/Redis/redisfile/9.png)   
## NoSQL数据库四大分类  
1. KV键值：典型介绍  
+ 新浪：BerkeleyDB+redis  
+ 美团：redis+tair  
+ 阿里、百度：memcache+redis  
2. 文档型数据库(bson格式比较多)：典型介绍  
+ CouchDB  
+ MongoDB  
MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。  
MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。  
3. 列存储数据库  
+ Cassandra, HBase
+ 分布式文件系统  
4. 图关系数据库  
+ 它不是放图形的，放的是关系比如:朋友圈社交网络、广告推荐系统  
+ 社交网络，推荐系统等。专注于构建关系图谱
+ Neo4J, InfoGrid
5. 对比  
![10](/Redis/redisfile/10.png)   
## 在分布式数据库中CAP原理CAP+BASE  
1. 传统的ACID分别是什么  
 
关系型数据库遵循ACID规则
事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：
 
1、A (Atomicity) 原子性
原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。  
 
2、C (Consistency) 一致性
一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。  
 
3、I (Isolation) 独立性
所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的  
 
4、D (Durability) 持久性
持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。    

2. CAP  
+ C:Consistency（强一致性）  
+ A:Availability（可用性）  
+ P:Partition tolerance（分区容错性）

3. CAP的3进2  
CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。
而由于当前的网络硬件肯定会出现延迟丢包等问题，所以
 
分区容忍性是我们必须需要实现的。
 
所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。

C:强一致性 A：高可用性 P：分布式容忍性
 CA 传统Oracle数据库
 
 AP 大多数网站架构的选择
 
 CP Redis、Mongodb
 
 注意：分布式架构的时候必须做出取舍。
一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性。
因此牺牲C换取P，这是目前分布式数据库产品的方向

一致性与可用性的决择
 
对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地
 
数据库事务一致性需求 
　　很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低， 有些场合对写一致性要求并不高。允许实现最终一致性。
 
数据库的写实时性和读实时性需求
　　对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比方说发一条消息之 后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。
 
对复杂的SQL查询，特别是多表关联查询的需求 
　　任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特别是SNS类型的网站，从需求以及产品设计角 度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。

